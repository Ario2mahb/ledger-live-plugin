#include "venus_plugin.h"

/* Load any Venus specific contracts we may need*/

#define _VENUS(address, underlying_ticker, underlying_decimals, vault_ticker, vault_decimals) \
    {address, underlying_ticker, underlying_decimals, vault_ticker, vault_decimals},

const contract_info_t contracts[] = {
// this contracts-info.txt file is autogenerated by script:
// /tests/harvest/update-contracts-info-b2c.mjs
// or type: cd tests && npm run update-harvest

#ifdef DEBUG
// Include vaults, vTokens used in the tests
#include "contracts-info-tests.txt"
#else
// this contracts-info.txt file can be autogenerated by script:
// /tests/update-contracts-info-b2c.mjs
// or type: cd tests && npm run venus-update  - 

// TODO: Venus team to provide an API to list contracts we may be interested in vTokens, Vaults and Pools

#include "contracts-info.txt"
#endif
};

contract_info_t *find_contract_info(const char *address) {
    int len = sizeof(contracts) / sizeof(contracts[0]);
    PRINTF("Contracts length: %d\n", len);
    for (int i = 0; i < len; i++) {
        contract_info_t *ci = &contracts[i];
        if (memcmp(address, (char *) PIC(ci->address), 42) == 0) return ci;
    }
    // when contract is not found
    return NULL;
}



void handle_finalize(void *parameters) {
    ethPluginFinalize_t *msg = (ethPluginFinalize_t *) parameters;
    context_t *context = (context_t *) msg->pluginContext;

    msg->uiType = ETH_UI_TYPE_GENERIC;

    // Set Max Number of screens - 

    // EDIT THIS: Set the total number of screen you will need.
    msg->numScreens = 2;
    // EDIT THIS: Handle this case like you wish to (i.e. maybe no additional screen needed?).
    // If the beneficiary is NOT the sender, we will need an additional screen to display it.
    if (memcmp(msg->address, context->beneficiary, ADDRESS_LENGTH) != 0) {
        msg->numScreens += 1;
    }

    // EDIT THIS: set `tokenLookup1` (and maybe `tokenLookup2`) to point to
    // token addresses you will info for (such as decimals, ticker...).

    //  Set tokenlookups based on selector
    //  msg->tokenLookup1 = NULL;
    //  msg->tokenLookup2 = NULL;
  
    // Processing all selectors even if no tokenlookups required, to enhance read-ability

    // Fill context underlying and vault ticker/decimals - loaded from contracts-info.txt for vTokens and Vault
    
    // TODO: started this for vToken, havent done Vaults, testing will reveal more but 'rain-stopped-play'

    char *addr = context->contract_address_sent;
    addr[0] = '0';
    addr[1] = 'x';

    uint64_t chainId = 0;
    getEthAddressStringFromBinary(msg->pluginSharedRO->txContent->destination,
                                  addr + 2,  // +2 here because we've already prefixed with '0x'.
                                  msg->pluginSharedRW->sha3,
                                  chainId);
    PRINTF("MSG Address: %s\n", addr);

    contract_info_t *info = find_contract_info(addr);

    switch (context->selectorIndex) {

        // *** Bep20
        case BEP20_APPROVE:
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
            msg->tokenLookup2 = context->contract_address_received;  //address spender
            break;

        // *** Venus vTokens
        case VENUS_MINT:
        case VENUS_REDEEM:
        case VENUS_REDEEM_UNDERLYING:
        case VENUS_BORROW:
        case VENUS_REPAY_BORROW:
            if (info) {                         // Found a local lookup in info, to display underlying ticker
                strlcpy(context->ticker_sent,
                       (char *) PIC(info->underlying_ticker),
                       sizeof(context->ticker_sent));
                context->decimals_sent = info->underlying_decimals;
            } else {
                msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
            }
            break;

        case VENUS_REPAY_BORROW_ON_BEHALF:
            msg->tokenLookup1 = context->contract_address_sent; // address vBnb
            break;

        case VENUS_PROVIDE_COLLATERAL:
            //msg->tokenLookup1 = context->contract_address_sent; TODO: when provide_parameter has passed address[] array
            break;

        case VENUS_REMOVE_COLLATERAL:
            msg->tokenLookup1 = context->contract_address_sent; // vToken address
            break;

        // *** Vaults ***
        case VAULT_DEPOSIT:
            // ?? msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
            break;
        
        case VAULT_DEPOSIT_TOKEN:
        case VAULT_WITHDRAW_TOKEN_EXECUTE:
        case VAULT_WITHDRAW_TOKEN_REQUEST:
            msg->tokenLookup1 = context->contract_address_sent; // Reward Token
            break;

        case VAULT_WITHDRAW_VAI:
        case VAULT_WITHDRAW_VRT:               
        case VAULT_CLAIM:
            break;            

        // *** Governance ***
        case VENUS_DELEGATE_VOTE:
        case VENUS_MAKE_PROPOSAL:
        case VENUS_CAST_VOTE:
        case VENUS_VOTE_WITH_REASON:
            break;

        // *** Convert ***
        case VENUS_CONVERT_VRT:
        case VENUS_WITHDRAW_VESTED_XVS:
            break;

        // *** Swap ***
        case SWAP_EXACT_TOKENS_FOR_TOKENS:
        case SWAP_TOKENS_FOR_EXACT_TOKENS:
            msg->tokenLookup1 = context->contract_address_sent;
            msg->tokenLookup2 = context->contract_address_received;
            break;

        case SWAP_EXACT_TOKENS_FOR_ETH:
        case SWAP_TOKENS_FOR_EXACT_ETH:
            msg->tokenLookup1 = context->contract_address_sent;
            break;

        case SWAP_EXACT_ETH_FOR_TOKENS:
        case SWAP_ETH_FOR_EXACT_TOKENS:
            msg->tokenLookup2 = context->contract_address_received;
            break;

        // *** VAI ***
        case VENUS_MINT_VAI:
        case VENUS_REPAY_VAI:        
            break;

        // Keep this
        default:
            PRINTF("Missing selectorIndex: %d\n", context->selectorIndex);
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            return;
    }

    msg->result = ETH_PLUGIN_RESULT_OK;
}
